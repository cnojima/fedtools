<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/utilities.js - fedtools</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/fedtools-logo.png" title="fedtools" width="150" height="31"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.114</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/git-helper.html">git-helper</a></li>
            
                <li><a href="../classes/utilities.html">utilities</a></li>
            
                <li><a href="../classes/wria2-bootstrap.html">wria2-bootstrap</a></li>
            
                <li><a href="../classes/wria2-serve.html">wria2-serve</a></li>
            
                <li><a href="../classes/yui3-utils.html">yui3-utils</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/fedtools.html">fedtools</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/utilities.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Utilities methods that can be used by multiple modules.
 *
 * @class utilities
 * @static
 * @module fedtools
 */
var _ = require(&#x27;underscore&#x27;),
  path = require(&#x27;path&#x27;),
  fs = require(&#x27;fs&#x27;),
  findit = require(&#x27;findit&#x27;),
  treeify = require(&#x27;treeify&#x27;),
  os = require(&#x27;osenv&#x27;),
  log = require(&#x27;fedtools-logs&#x27;),
  cmd = require(&#x27;fedtools-commands&#x27;),

  timeTrackerStart,
  fedtoolsEnvRcFile,
  fedtoolsRcKeys,

  PROMPT_PASSWORD = &#x27;password&#x27;,
  PROMPT_CONFIRM = &#x27;confirm&#x27;,
  PROMPT_PROMPT = &#x27;prompt&#x27;,

  ALIVE_SIGNAL = 0,
  KILL_SIGNAL = &#x27;SIGINT&#x27;;

fedtoolsEnvRcFile = path.join(process.env.HOME, &#x27;.fedtoolsrc&#x27;);

exports.FEDTOOLSRCKEYS = fedtoolsRcKeys = {
  username: &#x27;username&#x27;,
  useremail: &#x27;useremail&#x27;,
  userbranch: &#x27;userbranch&#x27;,
  yuibranch: &#x27;yuibranch&#x27;
};


// -- P R O P E R T I E S

/**
 * Use this signal to check if a process is running.
 *
 * @property ALIVE_SIGNAL
 * @type String
 * @static
 */
exports.ALIVE_SIGNAL = ALIVE_SIGNAL;
/**
 * Use this signal to kill a running process.
 *
 * @property KILL_SIGNAL
 * @type String
 * @static
 */
exports.KILL_SIGNAL = KILL_SIGNAL;
/**
 * Use this property in conjunction with promptAndContinue.
 *
 * @property PROMPT_PASSWORD
 * @type String
 * @static
 */
exports.PROMPT_PASSWORD = PROMPT_PASSWORD;
/**
 * Use this property in conjunction with promptAndContinue.
 *
 * @property PROMPT_CONFIRM
 * @type String
 * @static
 */
exports.PROMPT_CONFIRM = PROMPT_CONFIRM;
/**
 * Use this property in conjunction with promptAndContinue.
 *
 * @property PROMPT_PROMPT
 * @type String
 * @static
 */
exports.PROMPT_PROMPT = PROMPT_PROMPT;

// -- P R I V A T E  M E T H O D S

function _objectSort(obj) {
  if (typeof obj === &#x27;string&#x27;) {
    return obj;
  }
  var keys = Object.keys(obj).sort(),
    o = {};
  keys.forEach(function (i) {
    o[i] = _objectSort(obj[i]);
  });
  return o;
}


// -- P U B L I C  M E T H O D S

/**
 * Start or stop a timer.
 * Stopping the timer will also log the result in minutes, seconds and milliseconds.
 * The default introductory text (&#x27;Elapsed time:&#x27;) can be overridden.
 *
 * @method timeTracker
 * @param {String} type    The timeTracker action type (&#x27;start&#x27; or &#x27;stop&#x27;)
 * @param {String} [label] The introductory text to display when the timer stops.
 * Default to &quot;Elapsed time: &quot;
 *
 * @example
 *     utilities.timeTracker(&#x27;start&#x27;);
 *     longRunningTask();
 *     utilities.timeTracker(&#x27;stop&#x27;);
 */

exports.timeTracker = function (type, label) {
  if (type === &#x27;start&#x27;) {
    timeTrackerStart = process.hrtime();
  }
  if (type === &#x27;stop&#x27;) {
    var precision = 3,
      elapsedTotal = process.hrtime(timeTrackerStart)[0] * 1000 + process.hrtime(
        timeTrackerStart)[1] / 1000000,
      duration = require(&#x27;moment&#x27;).duration(elapsedTotal, &#x27;milliseconds&#x27;),
      arrElapse = [
        duration.get(&#x27;minutes&#x27;) ? duration.get(&#x27;minutes&#x27;) + &#x27;m&#x27; : &#x27;&#x27;,
        duration.get(&#x27;seconds&#x27;) ? duration.get(&#x27;seconds&#x27;) + &#x27;s&#x27; : &#x27;&#x27;,
        duration.get(&#x27;ms&#x27;) ? duration.get(&#x27;ms&#x27;).toFixed(precision) + &#x27;ms&#x27; : &#x27;&#x27;
      ],
      intro = label ? label : &#x27;Elapsed time: &#x27;;

    log.echo(intro + _.compact(arrElapse).join(&#x27;, &#x27;));

    // reset the timer
    timeTrackerStart = process.hrtime();
  }
};

/**
 * Finds the &#x60;wf2/src&#x60; path of a wria2 git repository.
 *
 * @method getWF2srcPath
 * @async
 * @param {Object}  options
 * @param {String}  options.cwd             The path where to run the command.
 * @param {Boolean} [options.silent=false]  If true, do no log the command line.
 * @param {Boolean} [options.verbose=false] If true, log stderr/stdout.
 
 * @param {Function} done Callback to execute when done. It gets 2 arguments:
 * @param {String}   done.error     On success, this will be null.
 * @param {String}   done.srcPath   The path to wf2/src of the wria2 repository.
 */

function _getWF2srcPath(options, done) {
  var srcPath;
  require(&#x27;./git-helper&#x27;).findGitRootPath(options, function (err, rootPath) {
    if (err) {
      done(err);
    } else {
      srcPath = path.join(rootPath, &#x27;wf2&#x27;, &#x27;src&#x27;);
      if (fs.existsSync(srcPath)) {
        done(null, srcPath);
      } else {
        done(1);
      }
    }
  });
}

/**
 * Provides a helper method to display a prompt and expect an answer.
 * Depending on the type of prompt requested, it will either accept
 * a simple Y/y/yes or N/n/no answer, or a more complex validation
 * scheme (that can be passed via the configuration).
 *
 * @method promptAndContinue
 * @async
 * @param {Object}   config
 * @param {String}   [config.infoMsg]    A heading message to be displayed
 *                                                  before the actual prompt.
 * @param {String}   config.promptType   PROMPT_PASSWORD PROMPT_CONFIRM PROMPT_PROMPT
 * @param {String}   config.promptMsg    The prompt message (it will end with an input caret).
 * @param {String}   [config.defaultValue] A default value in case the user presses ENTER.
 * @param {Function} [config.validator]    A function to validate the user input passed as
 * argument. Throw an error to invalidate the user entry and prompt again or return a value
 * (which could be what the user entered or a modified version of it).
 *
 * @param {Function} done Callback to execute when done. It gets 2 arguments:
 * @param {String}   done.error     On success, this will be null.
 * @param {String}   done.value     The value the user entered, or the default value, or the
 *                                  value returned by the validator function.
 *
 * @example
 *     utilities.promptAndContinue({
 *       promptType: utilities.PROMPT_PROMPT,
 *       promptMsg: &#x27;Type an existing path where you want to clone, or ENTER to use the current path:&#x27;,
 *       defaultValue: process.cwd(),
 *       validator: function (value) {
 *         var pathForClone;
 *         value = utilities.resolvePath(value);
 *         pathForClone = path.resolve(value);
 *         if (!fs.existsSync(pathForClone)) {
 *           log.error(&#x27;Invalid path: &#x27;, value);
 *           // prompt again
 *           throw new Error();
 *         } else {
 *           return pathForClone;
 *         }
 *       }
 *     }, callback);
 *
 *     utilities.promptAndContinue({
 *      promptType: utilities.PROMPT_CONFIRM,
 *      promptMsg: &#x27;Do you want to clone the wria2 git repository locally? [Y|n]&#x27;,
 *      defaultValue: true
 *     }, callback);
 *
 *     utilities.promptAndContinue({
 *       promptType: utilities.PROMPT_PASSWORD,
 *       promptMsg: &#x27;Type the password for user warbuilder:&#x27;,
 *       validator: function (value) {
 *         if (value === &#x27;&#x27;) {
 *           // prompt again
 *           throw new Error();
 *         } else {
 *           return value;
 *         }
 *       }
 *     }, function (err, value) {
 *       if (value) {
 *         userChoices.warbuilderuserpassword = value;
 *       }
 *       callback();
 *     });
 */
function _promptAndContinue(config, done) {
  var prompt = require(&#x27;promptly&#x27;);

  if (config.infoMsg) {
    log.info(config.infoMsg);
    log.echo();
  }
  if (config.promptType === PROMPT_PASSWORD) {
    prompt.prompt(config.promptMsg, {
      validator: config.validator,
      silent: true
    }, done);
  } else if (config.promptType === PROMPT_CONFIRM) {
    prompt.confirm(config.promptMsg, {
      &#x27;default&#x27;: (config.defaultValue !== undefined) ? config.defaultValue : false
    }, done);
  } else if (config.promptType === PROMPT_PROMPT) {
    if (config.defaultValue !== undefined) {
      prompt.prompt(config.promptMsg, {
        &#x27;default&#x27;: config.defaultValue,
        validator: config.validator,
      }, done);
    } else {
      prompt.prompt(config.promptMsg, {
        validator: config.validator,
      }, done);
    }

  }
}

/**
 * Resolve a path and replace &quot;~&quot; with $HOME if needed
 *
 * @method resolvePath
 * @param {String} pathString A path that can contain &#x27;~&#x27;.
 * @return {String} A resolved path.
 */
exports.resolvePath = function (pathString) {
  var home = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  return path.resolve(pathString.replace(&#x27;~&#x27;, home));
};

/**
 * Generates a string representing a tree of the folder structure passed
 * in argument.
 *
 * @method parseTree
 * @async
 * @param {String} start The path to parse.
 * @param {String} root The root path to base the tree from.
 *
 * @param {Function} done Callback to execute when done. It gets 1 argument:
 * @param {String}   done.tree    A string representing a tree.
 */
exports.parseTree = function (start, root, done) {
  var finder = findit(start),
    tree = {};

  finder.on(&#x27;path&#x27;, function (file, stat) {
    var relativePath = path.relative(start, file),
      node = tree,
      parts = relativePath.split(path.sep);

    if (relativePath.indexOf(&#x27;..&#x27;) !== 0) {
      parts.forEach(function (part, key) {
        if (key &lt; (parts.length - 1) || stat.isDirectory()) {
          part += path.sep;
        }
        if (typeof node[part] !== &#x27;object&#x27;) {
          node[part] = {};
        }
        node = node[part];
      });
    }
  });

  finder.on(&#x27;end&#x27;, function () {
    tree = _objectSort(tree);
    var str = treeify.asTree(tree, true),
      out = &#x27;&#x27;,
      rel = path.relative(path.join(root, &#x27;../&#x27;), start),
      len = rel.split(path.sep)[0].length,
      pad = function (str) {
        for (var i = 0; i &lt;= len; i += 1) {
          str = &#x27; &#x27; + str;
        }
        str = str.replace(&#x27;─&#x27;, &#x27;──&#x27;);
        return str;
      };

    str = str.split(&#x27;\n&#x27;);

    out += &#x27;   &#x27; + rel + &#x27;\n&#x27;;
    str.forEach(function (s) {
      out += &#x27;   &#x27; + pad(s) + &#x27;\n&#x27;;
    });
    done(out);
  });
};

/**
 * Checks if the current OS is Windows based.
 *
 * @method isWindows
 * @return {Boolean} True on if the OS is Windows.
 */
exports.isWindows = function () {
  return (process.platform === &#x27;win32&#x27;);
};

/**
 * Wrap a string given a maximum length, trying not to break words.
 *
 * @method wordWrap
 * @param  {String} str The string to wrap
 * @param  {String} [width=75] The maximum length of the desired width.
 * @return {String} The wrapped string.
 */
exports.wordWrap = function (str, width) {
  var regex;

  width = width || 75;
  if (!str) {
    return str;
  }
  regex = &#x27;.{1,&#x27; + width + &#x27;}(\\s|$)|\\S+?(\\s|$)&#x27;;
  return str.match(new RegExp(regex, &#x27;g&#x27;));
};

/**
 * Transform a string to setCamelCase.
 *
 * @method setCamelCase
 * @param  {String} input The string to convert to camelCase.
 * @return {String} The input string converted into camelCase format.
 */
exports.setCamelCase = function (input) {
  var str = input.toLowerCase().replace(/-(.)/g, function (match, group1) {
    return group1.toUpperCase();
  });
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * Runs &#x60;npm install&#x60; in the provided folder if &#x60;node_modules&#x60; doesn&#x27;t exist.
 *
 * @method installLocalNpmPackages
 * @async
 * @param {String} srcPath The path where a package.json file exists.
 *
 * @param {Function} done Callback to execute when done. It gets 1 argument:
 * @param {String}   done.error On success, this will be null.
 */
exports.installLocalNpmPackages = function (srcPath, done) {
  var nodeModulesPath = path.join(srcPath, &#x27;node_modules&#x27;);
  if (!fs.existsSync(nodeModulesPath)) {
    cmd.run(&#x27;npm install&#x27;, {
      status: true,
      verbose: false,
      pwd: srcPath
    }, function (err) {
      if (err) {
        log.error(&#x27;Unable to install npm packages!&#x27;);
        done(err);
      } else {
        done(null);
      }
    });
  } else {
    done(null);
  }
};

/**
 * Finds a temporary folder based on the OS. If /repo exists,
 * it will be used on Linux/Mac.
 *
 * @method getTemporaryDir
 * @return {String} Path to a temporary folder.
 */
exports.getTemporaryDir = function () {
  var osTmpDir, tmpDir;

  // forcing /repo or /tmp on linux and mac
  if (process.platform === &#x27;linux&#x27; || process.platform === &#x27;darwin&#x27;) {
    if (fs.existsSync(&#x27;/repo&#x27;)) {
      osTmpDir = &#x27;/repo&#x27;;
    } else {
      osTmpDir = &#x27;/tmp&#x27;;
    }
  } else {
    osTmpDir = os.tmpdir();
  }
  tmpDir = path.join(osTmpDir, &#x27;fedtools-tmp&#x27;);
  if (!fs.existsSync(tmpDir)) {
    require(&#x27;mkdirp&#x27;).sync(tmpDir);
  }
  return tmpDir;
};

/**
 * Finds the HOME directory based on the OS.
 *
 * @method getHomeDir
 * @return {String} Path to the home directory.
 */
exports.getHomeDir = function () {
  return os.home();
};

/**
 * Helper method to update the framework version string in all the relevant files.
 * It updates &#x60;.shifter.json&#x60; and uses Maven for the rest.
 * This method must be run within a WF-RIA2 folder.
 * It will display the current version and prompt the user to enter a new one.
 *
 * __NOTE__: local combo loader
 *
 * if the user enters &#x27;build&#x27; or &#x27;combo&#x27;, the &#x60;replace-wf2_combopath&#x60; key in the
 * &#x60;.shifter.json&#x60; file will be updated with &#x60;../../../wria/combo?basePath=build&amp;&#x60;
 *
 * @method wria2bump
 * @async
 *
 * @param {Function} done Callback to execute when done. It gets 1 argument:
 * @param {String}   done.error On success, this will be null.
 */
exports.wria2bump = function (done) {
  var msg = &#x27;Type the new version number you want to set: &#x27;,
    shifterCfg, currentVersion;

  _getWF2srcPath({
    cwd: process.cwd()
  }, function (err, srcPath) {
    if (!err &amp;&amp; srcPath) {
      var shifterJsonFile = path.join(srcPath, &#x27;.shifter.json&#x27;);

      if (!fs.existsSync(shifterJsonFile)) {
        log.error(&#x27;Ooops! It looks like you\&#x27;re missing a .shifter.json configuration file!&#x27;);
        done(-1);
      } else {
        shifterCfg = JSON.parse(fs.readFileSync(shifterJsonFile, &#x27;utf8&#x27;));
        currentVersion = shifterCfg[&#x27;replace-wf2_version&#x27;];
        log.info(&#x27;The current version is: &#x27;, currentVersion);

        _promptAndContinue({
          promptType: PROMPT_PROMPT,
          promptMsg: msg
        }, function (err, newVersion) {
          shifterCfg[&#x27;replace-wf2_version&#x27;] = newVersion;
          // special combo loader
          // if version is &#x27;build&#x27; or &#x27;combo&#x27;, replace
          // ../../../wria/combo?basePath=@WF2_VERSION@/build&amp;
          // with
          // ../../../wria/combo?basePath=build&amp;
          if (newVersion === &#x27;build&#x27; || newVersion === &#x27;combo&#x27;) {
            shifterCfg[&#x27;replace-wf2_combopath&#x27;] = &#x27;../../../wria/combo?basePath=build&amp;&#x27;;
          } else
          if (shifterCfg[&#x27;replace-wf2_combopath&#x27;] ===
            &#x27;../../../wria/combo?basePath=build&amp;&#x27;) {
            log.notice(&#x27;Restoring replace-wf2_combopath...&#x27;);
            shifterCfg[&#x27;replace-wf2_combopath&#x27;] =
              &#x27;../../../wria/combo?basePath=@WF2_VERSION@/build&amp;&#x27;;
          }
          fs.writeFileSync(shifterJsonFile, JSON.stringify(shifterCfg, null, 2));

          require(&#x27;async&#x27;).waterfall([

            function (callback) {
              var cmdline = &#x27;mvn versions:set -DnewVersion=&#x27; + newVersion +
                &#x27; -DgenerateBackupPoms=false&#x27;;
              cmd.run(cmdline, {
                pwd: path.join(srcPath, &#x27;..&#x27;, &#x27;..&#x27;)
              }, function (err) {
                callback(err);
              });
            }
          ], function (err) {
            if (!err) {
              log.echo();
              log.info(&#x27;All files have been updated with the new version.&#x27;);
              log.info(&#x27;Make sure it looks fine, then stage, commit and push!&#x27;);
              log.info(&#x27;You can commit by typing the following:&#x27;);
              log.echo();
              log.echo(&#x27;git commit -am &quot;Version bump to &#x27; + newVersion + &#x27;. NO TICKET&quot;&#x27;);
              log.echo();
            }
            done(err);
          });

        });
      }

    } else {
      log.error(&#x27;Is the current folder a wria2 path?&#x27;);
      log.echo();
      done(-1);
    }
  });
};

/**
 * Checks if a program or a list of programs are available.
 *
 * @method isAppInstalled
 * @param {Array|Object} options An object or an array of objects.
 * @param {String} options.name The name of the program to check.
 * @param {String} options.error An optional error message to display if
 *                              the given program cannot be found.
 * @return {Boolean} True on success (all programs are available).
 *
 * @example
 *     utilities.isAppInstalled([{
 *       name: &#x27;mvn&#x27;,
 *       error: &#x27;Maven is not installed on this machine&#x27;
 *     }, {
 *       name: &#x27;java&#x27;,
 *       error: &#x27;Java cannot be executed on this machine&#x27;
 *     }]);
 */
exports.isAppInstalled = function (options) {
  var cmdline, tmpRes, result = true;

  if (options &amp;&amp; !_.isArray(options)) {
    options = [options];
  }
  options.forEach(function (option) {
    if (process.platform === &#x27;win32&#x27;) {
      cmdline = option.name + &#x27; -h&#x27;;
    } else {
      cmdline = &#x27;type &#x27; + option.name;
    }
    tmpRes = cmd.run([cmdline], {
      status: false,
      verbose: false
    });
    if (tmpRes.code !== 0 &amp;&amp; option.error) {
      log.error(option.error);
      result = false;
    }
  });
  return result;
};

/**
 * Helper method to download a file over ssh.
 *
 * @method downloadFileOverSSH
 * @async
 * @param {Object} options
 * @param {String} options.srcFile    The remote file path + name.
 * @param {String} options.dstFile    The local file path + name.
 * @param {String} options.username   Username to ssh to the remote host.
 * @param {String} options.password   Password of the username.
 * @param {String} options.host       The remote hostname.
 * @param {String} [options.port=22]  The remote ssh port.
 *
 * @param {Function} done Callback to execute when done. It gets 1 argument:
 * @param {String}   done.error    On success, this will be null.
 */
exports.downloadFileOverSSH = function (options, done) {
  var readStream, writeStream, fs = require(&#x27;fs&#x27;),
    Connection = require(&#x27;ssh2&#x27;),
    c = new Connection();

  c.on(
    &#x27;ready&#x27;,
    function () {
      c.sftp(
        function (err, sftp) {
          if (err) {
            log.error(&#x27;Error, problem starting SFTP: %s&#x27;, err);
            done(err);
          }

          readStream = sftp.createReadStream(options.srcFile);
          writeStream = fs.createWriteStream(options.dstFile);

          // what to do when transfer finishes
          writeStream.on(
            &#x27;close&#x27;,
            function () {
              sftp.end();
              c.end();
            }
          );

          // initiate transfer of file
          readStream.pipe(writeStream);
        }
      );
    }
  );

  c.on(
    &#x27;error&#x27;,
    function (err) {
      log.error(&#x27;Connection error: %s&#x27;, err);
      done(err);
    }
  );

  c.on(
    &#x27;end&#x27;,
    function () {
      done();
    }
  );

  c.connect({
    host: options.host,
    port: options.port || 22,
    username: options.username,
    password: options.password
  });
};

/**
 * Helper method to send a POSIX signal to a running process.
 *
 * @method sendSignal
 * @param  {String|Number} pid   The recipient process id.
 * @param  {String}        signal The signal to send.
 * @return {Boolean} True on success.
 */
exports.sendSignal = function (pid, signal) {
  try {
    return process.kill(pid, signal);
  } catch (e) {
    return false;
  }
};

/**
 * Helper method to send an email. It is hard coded to use the local WF SMTP host.
 *
 * @method sendEmail
 * @async
 * @param {Object} options
 * @param {String} options.attachments  The path + filename of a local file to attach.
 * @param {String} options.from         The email &#x27;From&#x27; field.
 * @param {String|Array} options.to     The email &#x27;To&#x27; field (can be a string or an array of string).
 * @param {String} options.subject      The email &#x27;Subject&#x27; field.
 * @param {String} options.htmlBody     The email &#x27;Body&#x27; field in HTML format.
 *
 * @param {Function} done Callback to execute when done. It gets 1 argument:
 * @param {String}   done.error    On success, this will be null.
 */
exports.sendEmail = function (options, done) {
  // create reusable transport method (opens pool of SMTP connections)
  var mailOptions,
    smtpTransport,
    attachments,
    nodemailer = require(&#x27;nodemailer&#x27;);

  if (process.env.FEDTOOLS_PASSWORD) {
    smtpTransport = nodemailer.createTransport(&#x27;SMTP&#x27;, {
      service: &#x27;Gmail&#x27;,
      auth: {
        user: &#x27;wfportal@gmail.com&#x27;,
        pass: process.env.FEDTOOLS_PASSWORD
      }
    });
  } else {
    smtpTransport = nodemailer.createTransport(&#x27;SMTP&#x27;, {
      host: &#x27;cpowhl.wellsfargo.com&#x27;
    });
  }

  if (options.attachments) {
    attachments = [{
      filePath: options.attachments
    }];
  }

  // setup e-mail data with unicode symbols
  mailOptions = {
    from: options.from || &#x27;Fedtools &lt;arno.versini@wellsfargo.com&gt;&#x27;,
    to: options.to,
    subject: options.subject,
    html: options.htmlBody,
    attachments: attachments ? attachments : [],
    generateTextFromHTML: true
  };

  // send mail with defined transport object
  smtpTransport.sendMail(mailOptions, function (error) {
    if (error) {
      log.red(error);
    }
    smtpTransport.close(); // shut down the connection pool, no more messages
    done();
  });
};

/**
 * Helper method to set a user fedtools configuration into the global fedtools
 * configuration file. This file is located in the current user home directory.
 *
 * @method fedtoolsRcSet
 * @param {String} key    A valid fedtools key (ex: username, useremail, etc.)
 * @param {String} value  The value to set the key to.
 */
exports.fedtoolsRcSet = function (key, value) {
  if (_.contains(fedtoolsRcKeys, key)) {
    var json = {};
    if (fs.existsSync(fedtoolsEnvRcFile)) {
      json = JSON.parse(fs.readFileSync(fedtoolsEnvRcFile, &#x27;utf8&#x27;));
    }
    json[key] = value;
    fs.writeFileSync(fedtoolsEnvRcFile, JSON.stringify(json, null, 2));
  }
};

/**
 * Helper method to get a user fedtools configuration from the global fedtools
 * configuration file. This file is located in the current user home directory.
 *
 * @method fedtoolsRcGet
 * @param {String}  key    A valid fedtools key (ex: username, useremail, etc.)
 * @return {string} The value corresponding to the key or undefined if not found.
 */
exports.fedtoolsRcGet = function (key) {
  var json = {};
  if (_.contains(fedtoolsRcKeys, key)) {
    if (fs.existsSync(fedtoolsEnvRcFile)) {
      json = JSON.parse(fs.readFileSync(fedtoolsEnvRcFile, &#x27;utf8&#x27;));
    }
  }
  return json[key];
};

/**
 * Helper method to move a file. It uses pipes to circumvent the &#x60;mv&#x60; limits on
 * temporary folders (like /tmp).
 *
 * @method copyThenEraseSync
 * @param {String} src The source path + file to move.
 * @param {String} dst The destination path + file.
 */
exports.copyThenEraseSync = function (src, dst) {
  var is = fs.createReadStream(src),
    os = fs.createWriteStream(dst);

  is.pipe(os);
  is.on(&#x27;end&#x27;, function () {
    fs.unlinkSync(src);
  });
};

exports.unicorn = function () {
  // var unicornAscii = fs.readFileSync(path.join(__dirname, &#x27;..&#x27;, &#x27;data&#x27;, &#x27;unicorn.txt&#x27;), &#x27;utf8&#x27;);
  // log.echo();
  // log.echo(unicornAscii);
  // log.echo();
  return;
};

exports.getWF2srcPath = _getWF2srcPath;
exports.promptAndContinue = _promptAndContinue;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
