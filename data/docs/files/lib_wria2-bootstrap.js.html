<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/wria2-bootstrap.js - fedtools</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/fedtools-logo.png" title="fedtools" width="150" height="31"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.107</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/git-helper.html">git-helper</a></li>
            
                <li><a href="../classes/utilities.html">utilities</a></li>
            
                <li><a href="../classes/wria2-bootstrap.html">wria2-bootstrap</a></li>
            
                <li><a href="../classes/wria2-serve.html">wria2-serve</a></li>
            
                <li><a href="../classes/yui3-utils.html">yui3-utils</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/fedtools.html">fedtools</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/wria2-bootstrap.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Provides the wria2-bootstrap class.
 *
 * @class wria2-bootstrap
 * @static
 * @module fedtools
 */

var async = require(&#x27;async&#x27;),
  path = require(&#x27;path&#x27;),
  fs = require(&#x27;fs&#x27;),
  ncp = require(&#x27;ncp&#x27;).ncp,
  mustache = require(&#x27;mustache&#x27;),
  rimraf = require(&#x27;rimraf&#x27;),
  log = require(&#x27;fedtools-logs&#x27;),
  cmd = require(&#x27;fedtools-commands&#x27;),

  gith = require(&#x27;./git-helper&#x27;),
  build = require(&#x27;./wria2-build&#x27;),
  utilities = require(&#x27;./utilities&#x27;),
  yui3Utils = require(&#x27;./yui3-utils&#x27;),

  userChoices = {
    clone: &#x27;false&#x27;,
    cloneYui: &#x27;true&#x27;,
    path: &#x27;&#x27;,
    yui3path: &#x27;&#x27;,
    branch: &#x27;&#x27;,
    yuiBranch: &#x27;&#x27;,
    url: &#x27;&#x27;,
    build: &#x27;true&#x27;,
    combo: &#x27;false&#x27;,
    gitlabId: &#x27;&#x27;
  },
  SKIP_REPO_CLONING = &#x27;skip-repo-cloning&#x27;,
  cwd = process.cwd(),
  dstWf2srcPath,
  bootstrapped = false,
  srcHooksPath = path.join(__dirname, &#x27;..&#x27;, &#x27;data&#x27;,
    &#x27;git-repo-bootstrap&#x27;, &#x27;git-hooks&#x27;);

// -- P R I V A T E  M E T H O D S

function _askForRepoPath(answer, callback) {
  if (answer) {
    // yes, user wants to clone
    userChoices.clone = &#x27;true&#x27;;
    //let&#x27;s ask the next question: where?
    utilities.promptAndContinue({
      promptType: utilities.PROMPT_PROMPT,
      promptMsg: &#x27;Type an existing path where you want to clone, or ENTER to use the current path:&#x27;,
      defaultValue: cwd,
      validator: function (value) {
        var pathForClone;
        value = utilities.resolvePath(value);
        pathForClone = path.resolve(value);
        if (!fs.existsSync(pathForClone)) {
          log.error(&#x27;Invalid path: &#x27;, value);
          throw new Error();
        } else {
          return pathForClone;
        }
      }
    }, callback);
  } else {
    callback(SKIP_REPO_CLONING);
  }
}

function _checkForPathValidity(pathForClone, callback) {
  // Alright, user wants to clone into pathForClone
  // Let&#x27;s make sure it&#x27;s not a git repository...
  gith.isGitRepository({
    cwd: pathForClone
  }, function (err) {
    if (!err) {
      log.error(&#x27;Invalid path, it is already a git repo... Please choose a bare path...&#x27;);
      _askForRepoPath(true, function (err, repo) {
        _checkForPathValidity(repo, callback);
      });
    } else {
      // not a git repo but does the destination exist?
      var fullPath = path.join(pathForClone, userChoices.wria2gitname);
      if (!fs.existsSync(fullPath)) {
        callback(null, pathForClone);
      } else {
        log.error(&#x27;Invalid path! \&#x27;&#x27; + fullPath + &#x27;\&#x27; already exists&#x27;);
        _askForRepoPath(true, function (err, repo) {
          _checkForPathValidity(repo, callback);
        });
      }
    }
  });
}

function _gatherCloneRepoPath(done) {
  async.waterfall([

    function (callback) {
      utilities.promptAndContinue({
        promptType: utilities.PROMPT_CONFIRM,
        promptMsg: &#x27;Do you want to clone the wria2 git repository locally? [Y|n]&#x27;,
        defaultValue: true
      }, callback);
    },
    function (answer, callback) {
      _askForRepoPath(answer, callback);
    },
    function (pathForClone, callback) {
      _checkForPathValidity(pathForClone, callback);
    },
    function (pathForClone, callback) {
      userChoices.path = pathForClone;
      callback(null, pathForClone);
    }
  ], function (err, data) {
    done(err, data);
  });
}

function _askForExistingRepoPath(callback) {
  utilities.promptAndContinue({
    promptType: utilities.PROMPT_PROMPT,
    promptMsg: &#x27;Type an existing repository path, or ENTER to use the current path:&#x27;,
    defaultValue: cwd,
    validator: function (value) {
      var pathForInit;
      value = utilities.resolvePath(value);
      pathForInit = path.resolve(value);
      if (!fs.existsSync(pathForInit)) {
        log.error(&#x27;Invalid path: &#x27;, value);
        throw new Error();
      } else {
        return pathForInit;
      }
    }
  }, callback);
}

function _checkForRepoPathValidity(pathForInit, callback) {
  // Alright, user wants to clone into pathForClone
  // Let&#x27;s make sure it&#x27;s not a git repository...
  gith.isGitRepository({
    cwd: pathForInit
  }, function (err) {
    if (err) {
      log.error(&#x27;Invalid path, it is not a git repo...&#x27;);
      _askForExistingRepoPath(function (err, repo) {
        _checkForRepoPathValidity(repo, callback);
      });
    } else {
      // valid path, let&#x27;s save it
      userChoices.path = pathForInit;
      callback(null, pathForInit);
    }
  });
}

function _gatherWria2Branch(callback) {
  var msg = &#x27;Type the name of the WFRIA2 branch you need,&#x27; +
    &#x27; or ENTER to use the default&#x27;;
  utilities.promptAndContinue({
    promptType: utilities.PROMPT_PROMPT,
    promptMsg: msg + &#x27; [&#x27; + userChoices
      .branch + &#x27;]:&#x27;,
    defaultValue: userChoices.branch
  }, callback);
}

function _gatherYuiBranch(pkgConfig, callback) {
  var msg = &#x27;Type the name of the YUI3 branch you need,&#x27; +
    &#x27; or ENTER to use the default&#x27;;
  utilities.promptAndContinue({
    promptType: utilities.PROMPT_PROMPT,
    promptMsg: msg + &#x27; [&#x27; + userChoices.yuiBranch + &#x27;]:&#x27;,
    defaultValue: userChoices.yuiBranch
  }, callback);
}

function _gatherGitlabId(pkgConfig, callback) {
  var username = utilities.fedtoolsRcGet(utilities.FEDTOOLSRCKEYS.username),
    msg = &#x27;Type your git username (your fork name)&#x27;;
  if (username) {
    msg = msg + &#x27;, or ENTER for default [&#x27; + username + &#x27;]:&#x27;;
  } else {
    msg = msg + &#x27;:&#x27;;
  }
  utilities.promptAndContinue({
    promptType: utilities.PROMPT_PROMPT,
    promptMsg: msg,
    defaultValue: username || null
  }, function (err, value) {
    if (value) {
      utilities.fedtoolsRcSet(utilities.FEDTOOLSRCKEYS.username, value);
      userChoices.gitlabId = value;
      userChoices.url = mustache.render(pkgConfig.wria2giturl, {
        gitlabId: value
      });
    }
    callback(null);
  });
}

function _gatherUserChoices(pkgConfig, done) {
  async.waterfall([

    function (callback) {
      _gatherCloneRepoPath(function (err, pathForClone) {
        if (err &amp;&amp; err === SKIP_REPO_CLONING) {
          _askForExistingRepoPath(function (err, data) {
            if (!err) {
              _checkForRepoPathValidity(data, callback);
            } else {
              callback(-1);
            }
          });
        } else {
          // using clone
          callback(null, pathForClone);
        }
      });
    },
    function (arg, callback) {
      _gatherGitlabId(pkgConfig, callback);
    },
    function (callback) {
      _gatherWria2Branch(function (err, branch) {
        if (!err &amp;&amp; branch) {
          userChoices.branch = branch;
        }
        callback(err);
      });
    },
    function (callback) {
      userChoices.yuiBranch = &#x27;wf2-&#x27; + pkgConfig.defaultBranch;
      _gatherYuiBranch(pkgConfig, function (err, branch) {
        if (!err &amp;&amp; branch) {
          userChoices.yuiBranch = branch;
        }
        callback(err);
      });
    },
    function (callback) {
      utilities.promptAndContinue({
        promptType: utilities.PROMPT_CONFIRM,
        promptMsg: &#x27;Do you want to start a full build once the repo is ready? [Y|n]&#x27;,
        defaultValue: true
      }, function (err, value) {
        if (!err) {
          userChoices.build = (value) ? &#x27;true&#x27; : &#x27;false&#x27;;
        }
        callback(err);
      });
    },
    function (callback) {
      if (userChoices.build === &#x27;true&#x27;) {
        utilities.promptAndContinue({
          promptType: utilities.PROMPT_CONFIRM,
          promptMsg: &#x27;For the build, do you want to use the Combo Loader? [y|N]&#x27;,
          defaultValue: false
        }, function (err, value) {
          if (!err &amp;&amp; value) {
            userChoices.combo = &#x27;true&#x27;;
          }
          callback(err);
        });
      } else {
        callback();
      }
    }
  ], function (err) {
    done(err);
  });
}

function _cloneWria2(pkgConfig, done) {
  log.echo();
  gith.cloneGitRepository({
    url: userChoices.url,
    name: pkgConfig.wria2gitname,
    cwd: userChoices.path,
    silent: true,
    verbose: true
  }, function (err) {
    if (err) {
      log.fatal(&#x27;Ooops something went wrong, sorry, cannot go any further!&#x27;);
      done(1);
    } else {
      log.echo();
      log.success(&#x27;Repository cloned successfully&#x27;);
      userChoices.path = path.join(userChoices.path, pkgConfig.wria2gitname);
      done();
    }
  });
}

function _displayOptionsAndConfirmation(pkgConfig, callback) {
  log.echo();
  log.title(&#x27;SUMMARY OF OPTIONS&#x27;);
  log.echo();
  log.blue(&#x27;Clone WRIA2 repo     : &#x27;, (userChoices.clone === &#x27;false&#x27;) ? &#x27;no&#x27; : &#x27;yes&#x27;);
  log.blue(&#x27;Clone YUI3 repo      : &#x27;, (userChoices.cloneYui === &#x27;false&#x27;) ? &#x27;no&#x27; : &#x27;yes&#x27;);
  log.blue(&#x27;Sync WRIA2 with YUI3 : yes&#x27;);

  if (userChoices.cloneYui === &#x27;true&#x27;) {
    log.blue(&#x27;YUI3 git url         : &#x27;, pkgConfig.wria2yui3giturl);
  } else {
    log.blue(&#x27;YUI3 repository path : &#x27;, userChoices.yui3path);
  }

  if (userChoices.clone === &#x27;true&#x27;) {
    log.blue(&#x27;WRIA2 git url        : &#x27;, userChoices.url);
    log.blue(&#x27;Destination path     : &#x27;,
      path.join(userChoices.path, pkgConfig.wria2gitname));
  } else {
    log.blue(&#x27;Existing WRIA2 path  : &#x27;, userChoices.path);
  }
  log.blue(&#x27;WRIA2 branch         : &#x27;, userChoices.branch);
  log.blue(&#x27;YUI3 branch          : &#x27;, userChoices.yuiBranch);
  log.blue(&#x27;Start a build        : &#x27;, (userChoices.build === &#x27;false&#x27;) ? &#x27;no&#x27; : &#x27;yes&#x27;);
  if (userChoices.build === &#x27;true&#x27;) {
    log.blue(&#x27;Use Combo Loader     : &#x27;, (userChoices.combo === &#x27;false&#x27;) ? &#x27;no&#x27; : &#x27;yes&#x27;);
  }
  log.echo();

  utilities.promptAndContinue({
    promptType: utilities.PROMPT_CONFIRM,
    promptMsg: &#x27;Continue? [Y|n]&#x27;,
    defaultValue: true
  }, callback);
}

// -- C O M M A N D  L I N E  E N T R Y  P O I N T

/**
 * Helper method supposed to be called only for a command line direct call.
 * It uses several public APIs that can be used independently.
 *
 * This is used to bootstrap a WF-RIA2 git repository: it takes care of
 *synchronizing the corresponding YUI3 branch, as well as installing
 * git hooks and a few npm packages.
 *
 * It will:
 *    - Prompt the user for some options
 *        - Clone WF2 or use existing location
 *        - Where to clone (if cloning)
 *        - The fork name to clone (if cloning)
 *        - The WF-RIA2 branch name
 *        - The YUI3 branch name to synchronize with
 *        - Choice to start a full build once bootstrapped
 *
 * @method promptAndSync
 * @async
 * @param {Boolean} verbose    True to log stderr/stdout.
 * @param {Object}  pkgConfig  Object holding package.json &#x27;config&#x27; properties.
 
 * @param {Function} done Callback to execute when done. It gets 1 argument:
 * @param {String}   done.error     On success, this will be null.
 */
exports.bootstrapRepository = function (verbose, pkgConfig, done) {
  userChoices.wria2gitname = pkgConfig.wria2gitname;
  userChoices.branch = pkgConfig.defaultBranch;

  async.waterfall([

      function (callback) {
        _gatherUserChoices(pkgConfig, function () {
          if (userChoices.path &amp;&amp; userChoices.branch &amp;&amp; userChoices.clone) {
            callback(null);
          } else {
            callback(1);
          }
        });
      },
      function (callback) {
        if (userChoices.clone === &#x27;true&#x27;) {
          _displayOptionsAndConfirmation(pkgConfig, function (err, answer) {
            if (!err &amp;&amp; answer) {
              _cloneWria2(pkgConfig, callback);
            } else {
              log.echo(&#x27;Bye then...&#x27;);
              callback(-1);
            }
          });
        } else {
          gith.findGitRootPath({
            cwd: userChoices.path,
          }, function (err, rootPath) {
            if (err) {
              log.error(&#x27;Unable to find the root of the git repository! &#x27;);
              log.error(err);
              callback(err);
            } else {
              userChoices.path = rootPath;
              _displayOptionsAndConfirmation(pkgConfig, function (err, answer) {
                if (!err &amp;&amp; answer) {
                  callback();
                } else {
                  log.echo(&#x27;Bye then...&#x27;);
                  callback(-1);
                }
              });
            }
          });
        }
      },
      function (callback) {
        // need to go to the root of the git repo
        gith.findGitRootPath({
          cwd: userChoices.path,
        }, function (err, rootPath) {
          if (err) {
            log.error(&#x27;Unable to find the root of the git repository! &#x27;);
            log.error(err);
            callback(err);
          } else {
            dstWf2srcPath = path.join(rootPath, &#x27;wf2&#x27;, &#x27;src&#x27;);
            callback(null, path.join(rootPath, &#x27;.git&#x27;, &#x27;hooks&#x27;));
          }
        });
      },
      function (dstHooksPath, callback) {
        // need to copy git-hooks to the correct location
        ncp(srcHooksPath, dstHooksPath, function (err) {
          if (err) {
            log.error(err);
            callback(err);
          } else {
            log.success(&#x27;Git hooks copied successfully&#x27;);
            callback(null, dstHooksPath);
          }
        });
      },
      function (dstHooksPath, callback) {
        // need to run npm install in the hooks directory
        cmd.run(&#x27;npm install&#x27;, {
          status: true,
          verbose: false,
          pwd: dstHooksPath
        }, function (err) {
          if (err) {
            log.error(&#x27;Unable to install npm packages in the hooks directory!&#x27;);
            callback(err);
          } else {
            log.success(&#x27;Git hooks dependencies successfully installed&#x27;);
            callback(null);
          }
        });
      },
      function (callback) {
        // need to checkout the branch the user chose
        gith.checkoutBranch({
          cwd: userChoices.path,
          branch: userChoices.branch
        }, function (err) {
          if (!err) {
            log.success(&#x27;Current branch is now &#x27;, userChoices.branch);
            callback();
          } else {
            callback(err);
          }
        });
      },
      function (callback) {
        var upstreamUrl = mustache.render(pkgConfig.wria2giturl, {
          gitlabId: pkgConfig.defaultGitlabId
        });
        if (userChoices.gitlabId !== pkgConfig.defaultGitlabId) {
          // need to add upstream remote
          // git remote add upstream upstreamUrl
          gith.gitAddUpstreamRemote({
            cwd: dstWf2srcPath,
            url: upstreamUrl
          }, function (err) {
            if (!err) {
              log.success(&#x27;Adding remote pointing to upstream...&#x27;);
            }
            callback();
          });
        } else {
          // even if this failed, let&#x27;s still continue
          log.warning(&#x27;Unable to set the remote to upstream!&#x27;);
          callback();
        }
      },
      function (callback) {
        log.echo();
        yui3Utils.cloneTemporaryYui({
          branch: userChoices.yuiBranch,
          url: pkgConfig.wria2yui3giturl
        }, function (err, data) {
          callback(null, data);
        });
      },
      function (yui3path, callback) {
        // copy the yui source files to wf2/src
        yui3Utils.copyYUItoWF2(yui3path, userChoices.path, function (err) {
          if (!err) {
            // need to cleanup the temporary directory if it exists
            log.info(&#x27;Cleaning up temporary directory...&#x27;);
            rimraf(yui3path, callback);
          } else {
            callback(err);
          }
        });
      },
      function (callback) {
        bootstrapped = true;
        if (userChoices.build === &#x27;true&#x27;) {
          build.run(verbose, {
            cwd: dstWf2srcPath,
            combo: (userChoices.combo === &#x27;true&#x27;) ? true : false,
            prompt: false
          }, callback);
        } else {
          // user doesn&#x27;t want to build but we can still bootstrap
          // the build npm packages dependencies
          var buildPath = path.join(dstWf2srcPath, &#x27;..&#x27;, &#x27;..&#x27;, &#x27;build&#x27;);
          utilities.installLocalNpmPackages(buildPath, callback);
        }
      }
    ],
    function (err, data) {
      if (bootstrapped) {
        log.echo();
        log.info(&#x27;Your repository has been bootstrapped!&#x27;);

        if (userChoices.build === &#x27;true&#x27;) {
          if (!err) {
            log.info(&#x27;And successfully built!&#x27;);
            log.echo();
            log.echo(&#x27;You can start Selleck to view Example Pages using fedtools&#x27;);
          } else {
            log.info(&#x27;But something went wrong with the build :(&#x27;);
            log.echo(err);
            if (data) {
              console.log(data);
            }
          }
        }
      } else {
        if (err &amp;&amp; err !== -1) {
          log.fatal(&#x27;Something went wrong... cannot go any further!&#x27;);
          log.echo(err);
          if (data) {
            log.echo(data);
          }
        }
      }
      done();
    });
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
